# Jupyter Lab 项目代码总结：基于子空间的概率误差消除 (PEC)

本项目代码库主要围绕**量子误差消除 (Probabilistic Error Cancellation, PEC)** 技术在**量子纠错码子空间**中的应用进行数值模拟和分析。代码使用了 **JAX** 库进行高性能的数值计算，并利用 **Matplotlib** 和 **NumPy/Pandas** 进行数据处理和可视化。

## 1. 项目结构概览

项目文件主要分为三类：**基础功能 (Base)**、**核心算法 (PEC)** 和 **辅助工具 (Utils)**。

| 文件名 | 类别 | 主要功能 | 依赖关系 |
| :--- | :--- | :--- | :--- |
| `PEC_base.py` | 基础功能 | 定义量子信道、Pauli 算符、投影操作等核心数学工具。 | `jax`, `numpy`, `monitor` |
| `subspace_PEC.py` | 核心算法 | 实现基于子空间投影的 PEC 采样成本计算。 | `PEC_base.py`, `visualization.py` |
| `layered_subspace_PEC.py` | 核心算法 | 实现分层 PEC (Layered PEC) 的模拟，用于分析不同 $L_{check}$ 的影响。 | `subspace_PEC.py`, `visualization.py` |
| `layered_total_subspace_PEC.py` | 核心算法 | 实现更复杂的总分层 PEC 算法，结合了两个传输向量。 | `layered_subspace_PEC.py`, `visualization.py` |
| `layered_nopostselection_subspace_PEC.py` | 核心算法 | 引入带符号的投影操作，用于探索无后选择或特定逻辑子空间。 | `layered_total_subspace_PEC.py` |
| `pure_PEC_.py` | 核心算法 | 实现全空间 PEC 和分层 PEC 的对比模拟。 | `PEC_base.py` |
| `visualization.py` | 辅助工具 | 封装了绘图样式、数据处理和结果保存功能。 | `numpy`, `pandas`, `matplotlib`, `scipy` |
| `monitor.py` | 辅助工具 | 提供了函数执行时间、内存峰值等性能监控的装饰器和工具函数。 | `time`, `psutil`, `jax` |

---

## 2. 核心功能文件 (`PEC_base.py`) 函数总结

该文件定义了所有 PEC 算法所需的底层量子操作。

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `single_D(px, py, pz)` | 生成单个量子比特上的 Pauli 噪声信道 (超算符表示)。 | `px`, `py`, `pz` (float): Pauli X, Y, Z 错误概率。 | `(2, 2, 2, 2)` 形状的 JAX 数组 (超算符)。 |
| `tensor(C1, C2)` | 计算两个量子信道 $C_1$ 和 $C_2$ 的张量积。 | `C1`, `C2` (JAX 数组): 两个信道的超算符表示。 | `(i*a, j*b, k*c, d*l)` 形状的 JAX 数组 (张量积超算符)。 |
| `gen_error(p, std, n, key)` | 生成 $n$ 个量子比特的物理错误概率矩阵。 | `p` (float): 基础错误率；`std` (float): 错误率标准差；`n` (int): 量子比特数；`key` (JAX PRNGKey): 随机数种子。 | `(n, 3)` 形状的 JAX 数组 (每个比特的 $p_x, p_y, p_z$ 概率)。 |
| `gen_layered_error(error_matrix, L)` | 根据 $L$ 层电路的物理错误率，计算等效的单层错误率。 | `error_matrix` (`(n, 3)` JAX 数组)；`L` (int): 电路深度/层数。 | `(n, 3)` 形状的 JAX 数组 (等效单层错误率)。 |
| `tensor_single_pauli_noise(n, error_matrix)` | 利用二分法高效计算 $n$ 个量子比特的张量积噪声信道。 | `n` (int): 量子比特数；`error_matrix` (`(n, 3)` JAX 数组)。 | `(2^n, 2^n, 2^n, 2^n)` 形状的 JAX 数组 (总噪声信道)。 |
| `get_pauli(pauli_string)` | 将 Pauli 字符串 (如 "XYZI") 转换为对应的矩阵。 | `pauli_string` (str): Pauli 算符字符串。 | `(2^n, 2^n)` 形状的 JAX 数组 (Pauli 矩阵)。 |
| `gen_projector(n, pauli_list)` | 根据一组稳定子 (stabilizer) 算符生成子空间投影信道。 | `n` (int): 量子比特数；`pauli_list` (list): Pauli 矩阵列表。 | `(2^n, 2^n, 2^n, 2^n)` 形状的 JAX 数组 (投影信道)。 |
| `post_select(n, projector, N, pauli_list)` | 对噪声信道 $N$ 进行后选择 (投影到子空间)。 | `n` (int)；`projector` (JAX 数组)；`N` (JAX 数组)；`pauli_list` (list)。 | `probability` (float): 投影成功概率；`reduced_N` (JAX 数组): 归一化后的投影信道。 |
| `get_transfer_vector(n, k, reduced_N, projector)` | 将投影后的信道转化为逻辑子空间上的转移向量 (Transfer Vector)。 | `n` (int)；`k` (int): 逻辑比特数；`reduced_N` (JAX 数组)；`projector` (JAX 数组)。 | `(2^k, 2^k)` 形状的 JAX 数组 (转移向量)。 |
| `get_coefficient_vector(n, k, transfer_vector)` | 将转移向量转化为系数向量 (Coefficient Vector)。 | `n` (int)；`k` (int)；`transfer_vector` (JAX 数组)。 | `(2^k, 2^k)` 形状的 JAX 数组 (系数向量)。 |

---

## 3. 核心算法文件函数总结

### 3.1. `subspace_PEC.py`

该文件定义了在子空间上计算 PEC 采样成本的核心函数。

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `PEC_sample_cost(n, N_inv)` | 计算 PEC 采样成本的辅助函数，用于全空间或简化子空间。 | `n` (int)；`N_inv` (JAX 数组): 噪声信道的逆 (超算符表示)。 | `cost` (float): 采样成本值。 |
| `subspace_PEC(n, k, p, std, L, key, stabilizer_string)` | 计算给定电路深度 $L$ 下，基于子空间投影的 PEC 采样成本。 | `n`, `k`, `p`, `std`, `L`, `key` (见上文)；`stabilizer_string` (list/tuple): 稳定子字符串列表。 | `PEC_sample / probability` (float): 归一化后的 PEC 采样成本。 |

### 3.2. `pure_PEC_.py`

该文件实现了两种 PEC 算法的对比：

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `total_PEC(n, p, std, L, key)` | **全空间 PEC**：计算 $L$ 层电路的 PEC 采样成本，通过直接求 $L$ 层信道的逆。 | `n`, `p`, `std`, `L`, `key` (见上文)。 | `PEC_sample_cost(n, NL_inv)` (float): PEC 采样成本。 |
| `layered_PEC(n, p, std, L, key)` | **分层 PEC**：计算 $L$ 层电路的 PEC 采样成本，通过单层信道逆的 $L$ 次幂。 | `n`, `p`, `std`, `L`, `key` (见上文)。 | `PEC_sample_cost(n, N_inv)**L` (float): PEC 采样成本。 |

> **注：** `if __name__ == "__main__":` 块执行了这两种 PEC 成本随电路深度 $L$ 的变化模拟，并将结果保存到 `output.csv` 并绘制了 `PEC_Comparison_Final_300dpi.png`。

### 3.3. `layered_subspace_PEC.py`

该文件实现了分层 PEC 在子空间上的应用。

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `subspace_total_PEC(n, k, p, std, L, key, stabilizer_strings)` | 计算 $L$ 层电路在子空间上的投影成功概率和 PEC 样本值。 | `n`, `k`, `p`, `std`, `L`, `key`, `stabilizer_strings` (见上文)。 | `probability` (float): 投影成功概率；`PEC_sample` (float): PEC 样本值。 |

> **注：** `if __name__ == "__main__":` 块运行了分层 PEC 模拟，其中总电路深度 $L$ 被分解为 $L = q \cdot L_{check} + r$，并使用 $L_{check}$ 和 $L \pmod{L_{check}}$ 层的 PEC 样本值进行组合计算。结果将通过 `plot_all` 和 `save_results_to_csv` 进行处理。

### 3.4. `layered_total_subspace_PEC.py`

该文件是 `layered_subspace_PEC.py` 的扩展，提供了 JIT 编译的辅助函数和更精细的 PEC 组合逻辑。

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `compute_noise_and_postselect` | JIT 编译：计算噪声矩阵并进行后选择。 | `n`, `layered_error_matrix`, `projector`, `pauli_list`。 | `probability`, `reduced_N`。 |
| `compute_transfer_and_coefficient` | JIT 编译：计算转移向量和系数向量。 | `n`, `k`, `reduced_N`, `projector`。 | `transfer_vector`。 |
| `compute_PEC_sample` | JIT 编译：计算 PEC 样本值。 | `n`, `k`, `transfer_vector`。 | `PEC_sample`。 |

> **注：** `if __name__ == "__main__":` 块中的逻辑与 `layered_subspace_PEC.py` 类似，但它直接在主块中实现了 $L = q \cdot L_{check} + r$ 的组合逻辑，用于计算 $p_{matrix}$ (概率)、$pec_{matrix}$ (PEC 样本) 和 $total_{matrix}$ (总成本)。

### 3.5. `layered_nopostselection_subspace_PEC.py`

该文件引入了对稳定子特征值符号的控制，用于模拟无后选择或特定逻辑子空间。

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `gen_projector_pro(n, pauli_list, signs)` | **带符号的投影信道生成**：根据稳定子和期望的特征值符号 (`signs`) 生成投影信道。 | `n`, `pauli_list` (见上文)；`signs` (list/tuple): 稳定子特征值符号 (例如 `[1, -1]`)。 | `(2^n, 2^n, 2^n, 2^n)` 形状的 JAX 数组 (投影信道)。 |
| `subspace_total_PEC(n, k, p, std, L, key, stabilizer_strings, signs)` | 计算带符号投影的 PEC 样本值和概率。 | `n`, `k`, `p`, `std`, `L`, `key`, `stabilizer_strings`, `signs` (见上文)。 | `probability`, `PEC_sample`。 |

> **注：** `if __name__ == "__main__":` 块展示了如何使用不同的 `signs` 组合 (`(1,1)`, `(1,-1)`, `(-1,1)`, `(-1,-1)`) 来计算不同逻辑子空间的投影成功概率。

---

## 4. 辅助工具文件函数总结

### 4.1. `monitor.py`

该文件提供了性能监控工具。

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `format_time(seconds)` | 将秒数格式化为更易读的时间字符串 (微秒、毫秒、秒、分、小时)。 | `seconds` (float): 时间（秒）。 | `str`: 格式化后的时间字符串。 |
| `format_bytes(bytes_size)` | 将字节数格式化为更易读的内存字符串 (B, KB, MB, GB, TB)。 | `bytes_size` (float): 字节数。 | `str`: 格式化后的内存字符串。 |
| `monitor(f)` | **装饰器**：用于监控函数 `f` 的执行时间、启动/结束内存和内存峰值。 | `f` (function): 待监控的函数。 | `wrapper` (function): 包装后的函数，执行时会打印性能信息。 |

### 4.2. `visualization.py`

该文件提供了绘图和数据保存功能。

| 函数名 | 描述 | 输入 (Inputs) | 输出 (Output) |
| :--- | :--- | :--- | :--- |
| `setup_plot_style()` | 设置 Matplotlib 绘图样式为轻量级默认风格。 | 无 | 无 (修改 `plt.rcParams`) |
| `setup_nature_style()` | 设置 Matplotlib 绘图样式为类似 Nature 期刊的风格。 | 无 | 无 (修改 `plt.rcParams`) |
| `linear_func(x, a, b)` | 线性函数 $y = ax + b$，用于曲线拟合。 | `x`, `a`, `b` (float/array) | `a * x + b` (float/array) |
| `_select_p_slice(matrix, name, p_index)` | 确保矩阵为 2D 形状，并从 3D 矩阵中切片出特定 $p$ 索引的数据。 | `matrix` (numpy array)；`name` (str)；`p_index` (int)。 | `arr` (numpy array): 2D 矩阵。 |
| `plot_survival_probability(...)` | 绘制后选择失败率 ($1 - P_{succ}$) 随电路深度 $L$ 的变化图。 | `L_list`, `p_list`, `probs_matrix`。 | 无 (保存 `survival_probability.png`) |
| `plot_cost_comparison(...)` | 绘制 PEC 采样成本随电路深度 $L$ 的变化图，对比不同 $L_{check}$ 的结果。 | `L_list`, `L_check_list`, `p_matrix`, `pec_matrix`, `total_matrix`, `n`, `p`, `std`。 | 无 (保存 `cost_comparison.png`) |
| `plot_all(...)` | 包装函数，调用 `plot_survival_probability` 和 `plot_cost_comparison`。 | 所有绘图所需参数。 | 无 (保存两个图表) |
| `save_results_to_csv(...)` | 将模拟结果矩阵保存到 CSV 文件。 | `L_list`, `L_check_list`, `p_matrix`, `pec_matrix`, `total_matrix`；`filename` (str)。 | 无 (保存 `PEC_results.csv`) |
