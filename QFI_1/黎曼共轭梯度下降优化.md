## 任务描述：

目标：改变Q_real和Q_imag，最大化`cost(Q_real,Q_imag):=max_eig(Q_real,Q_imag,p)`，任务开始会给定p

变量：Q_real和Q_imag是两个实数矩阵:

​	`Q=Q_real+1j*Q_imag`

​	`Q.shape=(2**n,2**k)=:(N,K)`

约束：$\sum_{p=0}^{2**n-1}Q[p,i].conj()*Q[p,j] = \delta_{ij}$

## 黎曼共轭梯度算法

### 初始化

- 已经给定初始矩阵`Q_real` `Q_imag`
- 速度`V_real=zeros([N,K])` `V_imag = zeros([N,K])`

### 迭代优化

- 定义投影函数：效果是把A投到Q切空间，A和Q都是N*K复矩阵
  - `Proj(Q,A):=A-\frac{1}{2}Q@(A.T.conj()@Q+Q.T.conj()@A)`
- 定义计算norm函数：
  - `norm(A):=\sqrt{\Tr[A.T.conj()@A]}`
- 定义速度传输函数：
  - `trans(Q,V):=(V-Proj(Q,V))*norm(V)/norm(V-Proj(Q,V))`

参数：

- 学习率 : r
- 随机力强度 : gamma
- 速度decay率 : decay



循环：

- 随机初始化两个扰动矩阵
  - `delta_real.shape=(N,K)`
  - `delta_imag.shape=(N,K)`
- 利用JAX计算Q附近的梯度
  - `nabula_real.shape=(N,K)`
  - `nabula_imag.shape=(N,K)`
- 计算此步速度
  - `V_old = trans(Q,V)`
  - `V=gamma*delta+r*nabula+decay*V_old`
- 更新Q
  - `Q_new = Q+V`
  - `Q = QR(Q)`



循环停止条件？先采用固定步数循环