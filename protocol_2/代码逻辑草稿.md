逻辑线路：先采用ABCABC交错的双层重复逻辑线路，这不影响展示结果，便于编程。一层双比特门，一层单比特门

需要计算哪些东西？

最终目的：( PEC sample / P success ) ^ (L / T)

- P success的计算需要求和所有未通过error detection的分支概率，为此需要首先维护一个包含了T层O(n)个Pauli error的辛表示向量，判断清楚哪些通过哪些不通过
- PEC sample的计算需要求和所有通过error detection的分支概率，计算需求同上

因此只需逐层扩大Pauli error集合，逐层更新已有的辛表示向量，权重可以一次性全部随机初始化（或不随机化，在某均值附近分布）

每层初始的Pauli error是一样的，每三层执行的更新操作是一样的。我们首先

算法：

- Pauli error集合动态维护，每层首先增加O(n)个单比特、双比特贡献，接着propagate更新每一个元素，逐层迭代至T层，最终判断所有Pauli error与所有stabilizer generator的对易关系

我们假设线路的拓扑结构是1维环，所有的pauli error只包括单比特XYZ和相邻比特的九种组合

我们现在能计算出一共有error_terms项错误，其中有fail_terms项没通过，因此P_success = 1-p*fail_terms/error_terms

现在发现在n=15,p=0.0003的区间上，fail_terms*p > 1，此时一阶近似肯定失效。这是因为噪声模型选取不合适，不能认为双比特门系数与单比特门一样。

------

### a.4 实现多层clifford逻辑门

设计逻辑门，对于n qubit [[n,n-2,2]] error detection code，

ZZZZ , XXXX , ZIZI , ZIIZ , IXXI , IXIX = S1 , S2 , Z1 , Z2 , X1 , X2

CNOT12 : IZZZ , XIXX , ZIZI , ZIIZ , IXXI , IXIX

CNOT12 -> CNOT34 : IZIZ , XIXI , ZIZI , ZIZZ , IXXX , IXIX

CNOT12 -> CNOT34 -> CNOT14 : ZZIZ , XIXX , ZIZI , IIZZ , IXXX , IXIX

CNOT12 -> CNOT34 -> CNOT14 -> CNOT32 : ZZZZ , XXXX , ZIZI , IIZZ , IIXX , IXIX = S1 , S2 , Z1 , Z1Z2 , X1X2 , X2

logical CNOT12

logical_CNOTij = CNOT12 -> CNOTij -> CNOT1j -> CNOTi2

-------

### a.5 找一个算法进行demo

作为对比还需要做一个纯PEC版本的模拟。纯PEC其实也好做，如果每层都做，其实就是每层的gamma^2

$\prod_i (-1)^{s_i} = (-1)^{\oplus_i s_i}$

$\prod_{i} (-1)^{p_i+q_i}$

$\Pr(00) = \sum_{\vec{s}} \prod_i(w_i) \frac{1+(-1)^{\vec{u}\cdot \oplus\vec{v}(s_i)}}{2}$

$\sum_{\vec{s}} \prod_i(w_i) (-1)^{\vec{u}\cdot \oplus\vec{v}(s_i)} = P_+ - P_- = 2P_+ -1$

