逻辑线路：先采用ABCABC交错的双层重复逻辑线路，这不影响展示结果，便于编程。一层双比特门，一层单比特门

需要计算哪些东西？

最终目的：( PEC sample / P success ) ^ (L / T)

- P success的计算需要求和所有未通过error detection的分支概率，为此需要首先维护一个包含了T层O(n)个Pauli error的辛表示向量，判断清楚哪些通过哪些不通过
- PEC sample的计算需要求和所有通过error detection的分支概率，计算需求同上

因此只需逐层扩大Pauli error集合，逐层更新已有的辛表示向量，权重可以一次性全部随机初始化（或不随机化，在某均值附近分布）

每层初始的Pauli error是一样的，每三层执行的更新操作是一样的。我们首先

算法：

- Pauli error集合动态维护，每层首先增加O(n)个单比特、双比特贡献，接着propagate更新每一个元素，逐层迭代至T层，最终判断所有Pauli error与所有stabilizer generator的对易关系

我们假设线路的拓扑结构是1维环，所有的pauli error只包括单比特XYZ和相邻比特的九种组合

我们现在能计算出一共有error_terms项错误，其中有fail_terms项没通过，因此P_success = 1-p*fail_terms/error_terms

现在发现在n=15,p=0.0003的区间上，fail_terms*p > 1，此时一阶近似肯定失效。我们关心

# 混合 QEDC+PEC 协议模拟架构设计文档

**版本**: 1.0
**日期**: 2025-12-07
**目标**: 基于一阶近似稀疏噪声模型，利用 JAX 框架模拟并计算混合协议的采样开销 $Cost = (\gamma_{block} / P_{success})^{L/T}$。

---

## 1. 物理模型与数学表象

### 1.1 核心假设 (First-Order Approximation)
依据理论分析，在噪声较弱时，忽略 $O(p^2)$ 及更高阶项 。
- **噪声累积**：总噪声信道被视为各层噪声的线性叠加（而非卷积）。
- **数据结构**：无需维护全系统密度矩阵，仅需维护一个**Pauli Error 列表**及其对应的**标量权重** 。

### 1.2 辛表示 (Symplectic Representation)
为了适配 JAX 的高效矩阵运算，所有 Pauli 算符映射为二进制向量。
- **映射规则**: $P \to (x_1, \dots, x_n, z_1, \dots, z_n) \in \mathbb{Z}_2^{2n}$ 。
- **维度定义**:
  - `n_qubits`: $n$
  - `symplectic_dim`: $2n$
- **Clifford 门**: 表示为 $(2n \times 2n)$ 的辛矩阵 $S$，作用规则为 $v_{out} = v_{in} S \pmod 2$ 。

---

## 2. 系统模块划分 (Modules)

系统分为三个核心层次：**配置层**、**JAX 计算核**、**流程控制层**。

### 2.1 配置与常量 (Configuration)
定义物理系统的静态拓扑与参数，用于生成计算图常量。

- **`SystemConfig`**:
  - `n`: 量子比特数 (e.g., 100)
  - `T`: Block 周期 (e.g., 10)
  - `noise_params`: `{w1: float, w2: float}` (单/双比特噪声强度) 
  - `layout`: 描述 qubit 邻接关系 (1D Ring per `A13-5` )

### 2.2 核心计算算子 (JAX Core Kernels)
此部分函数需满足 Pure Function 要求，以便被 `jax.jit` 编译。

#### A. 基础运算 (Primitives)
1.  **`symplectic_inner_product(p1, p2)`**:
    -   计算 $p_1$ 与 $p_2$ 的对易性 。
    -   公式: $(x_1 \cdot z_2 + z_1 \cdot x_2) \pmod 2$.
2.  **`apply_clifford(paulis, symplectic_matrix)`**:
    -   批量更新 Pauli 算符 。
    -   实现: `jnp.dot(paulis, symplectic_matrix) % 2`.

#### B. 噪声生成器 (Noise Generator)
1.  **`generate_layer_noise(layer_idx)`**:
    -   根据层索引（奇数层/偶数层）确定门操作位置。
    -   生成对应的单比特 Pauli (X, Y, Z) 和双比特 Pauli ($P_i \otimes P_j$) 。
    -   **关键策略**: 使用 `Padding` 技术，确保每一层输出的 Tensor 形状固定（例如固定输出 $K_{max}$ 个项，不足处填 Identity，权重设为 0），以满足 JAX 静态图要求。

#### C. 传播算子 (Propagator)
1.  **`precompute_effective_unitaries(T, circuit_layout)`**:
    -   **优化策略**: 避免在主循环中反复进行矩阵乘法。
    -   预先计算从第 $t$ 层到第 $T$ 层的累积 Clifford 变换 $U_{eff}[t] = U_T \cdot U_{T-1} \cdots U_{t+1}$ 。
    -   输出: Shape `(T, 2n, 2n)` 的张量。

#### D. 检测与统计 (Detector & Stats)
1.  **`check_stabilizers(accumulated_paulis, stabilizer_matrix)`**:
    -   利用 `jax.vmap` 并行计算所有累积噪声项与所有 Stabilizer 生成元的对易关系 。
    -   输出: `syndrome_matrix` (Shape: `[Total_Terms, Num_Stabilizers]`)。
2.  **`compute_block_metrics(weights, syndromes)`**:
    -   **Masking**: 根据 syndrome 是否全为 0 生成布尔掩码 `is_survived`。
    -   **Reduction**:
        -   $P_{survived} = \sum (w_i \cdot \text{mask}_i)$
        -   $P_{total} = \sum w_i$
        -   $P_{success} \approx 1 - (P_{total} - P_{survived})$ 
        -   $\gamma_{block} \approx 1 + 2 \times \frac{P_{survived}}{P_{success}}$ 

---

## 3. 算法流程 (Workflow Logic)

整个模拟过程被封装为一个 `simulate_block` 函数。

### 步骤 1: 预计算 (Pre-computation)
- 构建 Stabilizer check matrix $S_{check}$ 。
- 构建每一层的等效传播矩阵 $U_{eff}$。

### 步骤 2: 堆叠 (Stacking) - `jax.lax.scan` 或 `fori_loop`
- 初始化空的 `GlobalPauliStack` 和 `GlobalWeightStack`。
- **循环 $t = 0 \to T-1$**:
    1.  **Generate**: 获取第 $t$ 层的原始噪声项 $E_t$ 和权重 $W_t$ 。
    2.  **Propagate**: 计算 $E'_t = E_t \cdot U_{eff}[t]$ (将噪声推至 Block 末端) 。
    3.  **Store**: 将 $E'_t, W_t$ 存入全局堆栈。

### 步骤 3: 批量检测 (Batch Detection)
- 输入 `GlobalPauliStack` (包含 $T \times O(n)$ 个项)。
- 执行 `check_stabilizers` 得到存活掩码。

### 步骤 4: 结果输出
- 计算并返回字典:
    ```python
    {
        "gamma_block": float,
        "p_success": float,
        "sampling_cost_scaling": (gamma_block / p_success) ** (1/T)
    }
    ```
- 该 Scaling 指标直接对应 $L/T$ 次方的底数 。

---

## 4. 关键实现细节与性能优化

### 4.1 静态形状 (Static Shapes)
JAX JIT 编译要求数组形状在编译时已知。
- **策略**: 计算最大可能的噪声项数 $N_{max} = T \times N_{layer\_max}$。
- 初始化 `PauliStack` 为 Shape `(N_max, 2n)` 的全 0 矩阵。
- 初始化 `WeightStack` 为 Shape `(N_max,)` 的全 0 向量。
- 实际噪声项填入，无效位保持 0 权重，不影响最终求和结果。

### 4.2 向量化内积 (Vectorized Inner Product)
不再使用双重循环计算内积。
- 使用 `jax.vmap` 将 `symplectic_inner_product` 映射到 `(N_terms, N_stabilizers)` 的网格上。
- 这将复杂度为 $O(T \cdot n^3)$ 的操作  转化为高度并行的 GPU 矩阵操作。

### 4.3 内存效率
- 存储需求约为 $O(T \cdot n^2)$ bit。
- 对于 $n=100, T=100$，Pauli 堆栈大小约为 $10^4 \times 200$ bits $\approx 250$ KB。
- 即使在消费级显卡上也能轻松扩展至 $n=1000$ 以上。

---

## 5. 验证方案 (Validation)

1.  **Limit Check**: 当 $w \to 0$ 时，应有 $\gamma \to 1$ 且 $P_{success} \to 1$。
2.  **Comparison**: 在小规模 ($n=4, T=2$) 下，与基于密度矩阵的全模拟结果对比（验证一阶近似的有效性）。
3.  **Scaling Check**: 复现 `log.md` 中提到的 $T$ 越小 Cost 越小的趋势。