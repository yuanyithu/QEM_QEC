逻辑线路：先采用ABCABC交错的双层重复逻辑线路，这不影响展示结果，便于编程。一层双比特门，一层单比特门

需要计算哪些东西？

最终目的：( PEC sample / P success ) ^ (L / T)

- P success的计算需要求和所有未通过error detection的分支概率，为此需要首先维护一个包含了T层O(n)个Pauli error的辛表示向量，判断清楚哪些通过哪些不通过
- PEC sample的计算需要求和所有通过error detection的分支概率，计算需求同上

因此只需逐层扩大Pauli error集合，逐层更新已有的辛表示向量，权重可以一次性全部随机初始化（或不随机化，在某均值附近分布）

每层初始的Pauli error是一样的，每三层执行的更新操作是一样的。我们首先

算法：

- Pauli error集合动态维护，每层首先增加O(n)个单比特、双比特贡献，接着propagate更新每一个元素，逐层迭代至T层，最终判断所有Pauli error与所有stabilizer generator的对易关系

我们假设线路的拓扑结构是1维环，所有的pauli error只包括单比特XYZ和相邻比特的九种组合

我们现在能计算出一共有error_terms项错误，其中有fail_terms项没通过，因此P_success = 1-p*fail_terms/error_terms

现在发现在n=15,p=0.0003的区间上，fail_terms*p > 1，此时一阶近似肯定失效。这是因为噪声模型选取不合适，不能认为双比特门系数与单比特门一样。

# `protocol_order_1.py` 代码逻辑梳理

## 1. 项目概述
该脚本对应项目日志 `log.md` 中的 **“a.4 使用1阶PEC，并计算”** 阶段。
- **目的**：数值模拟在“稀疏噪声 + 1阶PEC + Error Detection”方案下，不同探测间隔 $T$ 对总采样成本（Sample Cost）的影响。
- **物理模型**：基于 Symplectic 表示法的 Pauli 噪声模型，采用 Global Stabilizer 进行探测。
- **当前状态**：代码主要验证噪声积累与 PEC 代价的统计规律，**尚未开启逻辑门传播（Gate Propagation）**，仅模拟了噪声在多层线路中的线性叠加。

## 2. 核心数据结构
- **Pauli String (Symplectic Representation)**
  - 使用长度为 $2n$ 的 `int16` numpy 数组。
  - **映射规则**：
    - 前 $n$ 位：$X$ 分量（1表示存在）。
    - 后 $n$ 位：$Z$ 分量（1表示存在）。
    - 例如：第 $i$ 个 qubit 上的 $Y$ 门表示为 `arr[i]=1` 且 `arr[i+n]=1`。

## 3. 函数逻辑详解

### 3.1 基础工具函数
* **`gen_vec(positions, name, n)`**
    * **功能**：生成指定位置的 Pauli 错误向量。
    * **逻辑**：解析 `name`字符串（如 "X", "YZ"），在对应的 Symplectic 向量位置置 1。支持单比特和多比特错误生成。
* **`gen_stabilizer_list(n)`**
    * **功能**：生成用于 Error Detection 的全局 Stabilizer 组。
    * **输出**：包含两个算符：
        1.  全 $X$ 算符 (`all_X`: 前 $n$ 位为1)。
        2.  全 $Z$ 算符 (`all_Z`: 后 $n$ 位为1)。
* **`init_gate_info(n)`**
    * **功能**：定义各层的 CNOT 门连接拓扑（Brick-wall 结构）。
    * **现状**：仅定义了拓扑结构，但在 `propagate` 函数中未被实际调用进行状态更新。

### 3.2 核心物理模拟函数

* **`propagate(n, T, p1, p2)`**
    * **功能**：模拟 $T$ 层线路内的噪声项积累。
    * **输入**：Qubit数 $n$, 层数 $T$, 单比特错误率 $p1$, 双比特错误率 $p2$。
    * **逻辑流程**：
        1.  初始化：生成第0层的 $3n$ 个单比特噪声和 $9n$ 个双比特噪声。
        2.  **循环 $T-1$ 次**：
            * *(关键注意)*：代码中 `single_layer_propagate` 被注释，意味着**没有执行逻辑门对错误的传播**。
            * 仅执行**噪声注入**：每一层单纯追加新的 $3n$ 个单比特和 $9n$ 个双比特噪声项到 `error_list`。
    * **输出**：累积的所有可能的错误项列表及其对应的概率权重。

* **`error_detect(n, error_list, stabilizer_list, error_parameter_list)`**
    * **功能**：模拟 Error Detection 过程，分离通过与未通过探测的错误。
    * **判据**：计算错误项 $E$ 与 Stabilizer $S$ 的对易关系。使用 Symplectic 内积：
        $$c = (x_E \cdot z_S + z_E \cdot x_S) \pmod 2$$
        若 $c=1$ 则反对易（被探测），若 $c=0$ 则对易（存活）。
    * **输出**：
        * `fail_weight`: 被探测到的错误概率总和。
        * `success_weight`: 未被探测到的错误概率总和（用于后续 PEC 修正）。

* **`sample_cost(n, p1, p2, T)`**
    * **功能**：计算单次探测间隔（长度 $T$）的采样开销。
    * **计算公式**：
        1.  通过率 $P_{success} = 1 - \text{fail\_weight}$。
        2.  PEC 放大因子（一阶近似）：$\gamma = 1 + 2 \times \frac{\text{success\_weight}}{P_{success}}$。
        3.  单段采样成本：$\text{sample} = \frac{\gamma^2}{P_{success}}$。

## 4. 主程序流程 (`if __name__ == "__main__":`)
1.  **参数设定**：
    * $n=1000$ (高量子比特数，得益于经典模拟的高效性)。
    * $p_1 = 10^{-6}, p_2 = p_1^2$ (极低噪声区间，符合微扰论假设)。
    * $L=3000$ (线路总深度)。
2.  **扫描 $T$**：遍历 $T \in [1, 50)$。
3.  **总成本计算**：
    * 将总线路 $L$ 切分为 $\lfloor L/T \rfloor$ 个长度为 $T$ 的标准段和 1 个余数段。
    * 总采样成本：
        $$\text{Total Sample} = (\text{sample}_T)^{\lfloor L/T \rfloor} \times \text{sample}_{L\%T}$$
4.  **绘图**：输出 $\log_{10}(\text{Cost})$、Fail Weight、Success Weight 随 $T$ 的变化曲线。

## 5. 总结与日志对应
* **对应日志**：`log.md` -> `a.4 使用1阶PEC，并计算`
* **验证点**：
    * 日志提到“没做门是一个原因”，对应代码中 `propagate` 函数内注释掉的门传播逻辑。
    * 日志提到“PC上分钟级别时间能算到n=1000”，对应主程序中 $n=1000$ 的设定。
    * 日志提到“严格的拟合关系”，这是由于未做门传播，错误积累仅为线性叠加导致的。